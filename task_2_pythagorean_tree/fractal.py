"""
Рекурсивна логіка побудови фрактала "дерево Піфагора".

Містить функції для обчислення координат гілок дерева за допомогою рекурсії.
"""

import math


def calculate_pythagorean_tree(
    x1: float,
    y1: float,
    x2: float,
    y2: float,
    level: int,
    max_level: int,
    angle: float = 45
) -> list[tuple[float, float, float, float, float]]:
    """
    Обчислює координати гілок дерева Піфагора рекурсивно.
    
    Використовує геометричний підхід: для кожного квадрата обчислюємо
    дочірні квадрати на основі напрямку верхньої сторони та кута розгалуження.
    
    Args:
        x1, y1: Координати початку відрізка (нижня сторона квадрата)
        x2, y2: Координати кінця відрізка (нижня сторона квадрата)
        level: Поточний рівень рекурсії
        max_level: Максимальний рівень рекурсії
        angle: Кут розгалуження (в градусах)
        
    Returns:
        Список кортежів (x1, y1, x2, y2, size) для кожного квадрата
    """
    squares = []
    
    # Обчислюємо розмір поточного квадрата (довжина нижньої сторони)
    L = math.hypot(x2 - x1, y2 - y1)
    
    # Додаємо поточний квадрат до списку
    squares.append((x1, y1, x2, y2, L))
    
    # Базовий випадок: якщо досягли максимального рівня, повертаємо список
    if level >= max_level:
        return squares

    # Нормалізуємо вектор напрямку нижньої сторони квадрата
    dx = (x2 - x1) / L
    dy = (y2 - y1) / L
    
    # Обчислюємо перпендикулярний вектор (для верхньої сторони)
    # Повертаємо вектор (dx, dy) на 90° проти годинникової стрілки: (-dy, dx)
    perp_dx = -dy
    perp_dy = dx

    # Середина нижньої сторони квадрата
    mid_bottom_x = (x1 + x2) / 2
    mid_bottom_y = (y1 + y2) / 2
    
    # Середина верхньої сторони квадрата (точка розгалуження)
    # Переміщуємося від середини нижньої сторони перпендикулярно вгору на відстань L
    mid_x = mid_bottom_x + perp_dx * L
    mid_y = mid_bottom_y + perp_dy * L

    # Розмір дочірнього квадрата (зменшується в sqrt(2) разів)
    child = L / math.sqrt(2)
    
    # Відстань від середини верхньої сторони до середини основи дочірнього квадрата
    # Це половина розміру дочірнього квадрата
    offset = child / 2

    # Кут напрямку нижньої сторони (в радіанах)
    base_angle = math.atan2(dy, dx)
    
    # Кут напрямку верхньої сторони (перпендикулярно до нижньої, +90°)
    top_angle = base_angle + math.pi / 2

    # Обробляємо обидві гілки (ліву та праву) в циклі
    # sign = +1 для правої гілки, sign = -1 для лівої гілки
    for sign in (+1, -1):
        # Напрямок руху до середини основи дочірнього квадрата
        # Повертаємо напрямок верхньої сторони на кут angle вліво (-) або вправо (+)
        move_angle = top_angle + sign * math.radians(angle)
        
        # Середина основи дочірнього квадрата
        # Від середини верхньої сторони рухаємося на відстань offset у напрямку move_angle
        center_x = mid_x + offset * math.cos(move_angle)
        center_y = mid_y + offset * math.sin(move_angle)
        
        # Напрямок основи дочірнього квадрата (перпендикулярно до напрямку руху)
        # Повертаємо на 90° за годинниковою стрілкою
        square_angle = move_angle - math.pi / 2

        # Половина довжини основи дочірнього квадрата (вектор)
        hx = (child / 2) * math.cos(square_angle)
        hy = (child / 2) * math.sin(square_angle)

        # Координати основи дочірнього квадрата
        # Від середини основи віднімаємо/додаємо половину довжини
        cx1 = center_x - hx
        cy1 = center_y - hy
        cx2 = center_x + hx
        cy2 = center_y + hy

        # Рекурсивно обчислюємо координати для дочірніх квадратів
        squares.extend(calculate_pythagorean_tree(cx1, cy1, cx2, cy2,
                                                level + 1, max_level, angle))

    return squares