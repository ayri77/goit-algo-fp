# Завдання 1: Однозв'язний список

## Опис

Реалізація операцій з однозв'язним списком: реверсування, сортування та об'єднання відсортованих списків.

## Реалізовані функції

### 1. Реверсування списку

**Методи:**
- `reverse()` - реверсує список in-place, змінюючи посилання між вузлами
- `reversed()` - повертає новий реверсований список, не змінюючи оригінал

**Алгоритм:**
- Ітерація по списку зі зміною посилань `next` кожного вузла
- Складність: O(n) за часом, O(1) за пам'яттю (in-place)

**Приклад:**
```
Початковий список: 1 -> 2 -> 3 -> 4
Після reverse():   4 -> 3 -> 2 -> 1
```

### 2. Сортування списку

**Методи:**
- `sort()` - сортує список in-place
- `sorted()` - повертає новий відсортований список

**Алгоритм:** Merge Sort (сортування злиттям)
- Рекурсивне розділення списку на дві частини
- Злиття відсортованих частин
- Складність: O(n log n) за часом, O(log n) за пам'яттю (через рекурсію)

**Приклад:**
```
Початковий список: 5 -> 2 -> 8 -> 1 -> 9
Після sort():      1 -> 2 -> 5 -> 8 -> 9
```

### 3. Об'єднання відсортованих списків

**Методи:**
- `merge(list1, list2)` - статичний метод, об'єднує два відсортовані списки
- `merge_with(other)` - метод екземпляра, об'єднує поточний список з іншим

**Алгоритм:**
- Порівняння елементів з обох списків
- Додавання меншого елемента до результату
- Складність: O(n + m), де n і m - довжини списків

**Приклад:**
```
Перший список:  1 -> 3 -> 5
Другий список:  2 -> 4 -> 6
Об'єднаний:     1 -> 2 -> 3 -> 4 -> 5 -> 6
```

## Результати тестування

### Таблиця продуктивності

| Операція | Складність | Приклад (n=1000) |
|----------|------------|------------------|
| `reverse()` | O(n) | ~0.001 сек |
| `sort()` | O(n log n) | ~0.01 сек |
| `merge()` | O(n + m) | ~0.001 сек |

### Результати виконання

**Тест 1: Реверсування**
```
Вхід:  [1, 2, 3, 4, 5]
Вихід: [5, 4, 3, 2, 1]
Статус: ✅ Успішно
```

**Тест 2: Сортування**
```
Вхід:  [5, 2, 8, 1, 9, 3]
Вихід: [1, 2, 3, 5, 8, 9]
Статус: ✅ Успішно
```

**Тест 3: Об'єднання**
```
Вхід 1: [1, 3, 5]
Вхід 2: [2, 4, 6]
Вихід:  [1, 2, 3, 4, 5, 6]
Статус: ✅ Успішно
```

## Особливості реалізації

1. **Оптимізація append()**: Зберігання посилання на хвіст списку дозволяє додавати елементи за O(1)
2. **In-place операції**: `reverse()` та `sort()` модифікують існуючий список без створення копій
3. **Ітератор**: Реалізовано `__iter__()` для зручної ітерації по списку
4. **Method chaining**: Методи повертають `self` для підтримки ланцюжкових викликів

## Висновки

1. **Коректність**: Всі функції працюють правильно та відповідають вимогам завдання
2. **Ефективність**: Використано оптимальні алгоритми (merge sort для сортування)
3. **Гнучкість**: Надано як in-place, так і non-destructive методи
4. **Тестування**: Всі тести проходять успішно (юніт-тести та інтеграційні)

## Запуск

```bash
cd task_1_linked_list
python main.py
```

## Тестування

```bash
# Всі тести
pytest test_*.py -v

# Конкретний тест
pytest test_reverse.py -v
pytest test_sort.py -v
pytest test_merge.py -v
```

