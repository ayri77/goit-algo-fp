# План робіт для фінального проекту з алгоритмів

## Загальна інформація

Цей документ містить детальний план виконання фінального проекту з курсу "Алгоритми". Проект складається з 7 завдань, кожне з яких демонструє різні аспекти алгоритмів та структур даних.

## Структура проекту

```
goit-algo-fp/
├── task_1_linked_list/       # Завдання 1: Однозв'язний список
├── task_2_pythagorean_tree/   # Завдання 2: Фрактал дерево Піфагора
├── task_3_dijkstra/           # Завдання 3: Алгоритм Дейкстри
├── task_4_heap_visualization/ # Завдання 4: Візуалізація бінарної купи
├── task_5_tree_traversal/     # Завдання 5: Обхід бінарного дерева
├── task_6_greedy_dp/          # Завдання 6: Жадібний алгоритм та ДП
├── task_7_monte_carlo/        # Завдання 7: Метод Монте-Карло
└── common/                    # Спільні модулі
```

## Послідовність виконання

Рекомендується виконувати завдання в порядку їх нумерації, оскільки вони поступово ускладнюються та базуються на попередніх концепціях.

## Детальний план завдань

### Завдання 1: Структури даних. Сортування. Робота з однозв'язним списком

**Файли для реалізації:**
- `task_1_linked_list/linked_list.py` - базовий клас LinkedList
- `task_1_linked_list/reverse.py` - функція реверсування
- `task_1_linked_list/sort.py` - алгоритм сортування
- `task_1_linked_list/merge.py` - об'єднання відсортованих списків
- `task_1_linked_list/main.py` - демонстрація та тести

**Кроки виконання:**
1. Реалізувати базовий клас LinkedList з операціями append, prepend, display
2. Реалізувати функцію reverse_linked_list, яка змінює посилання між вузлами
3. Реалізувати алгоритм сортування (рекомендується сортування злиттям)
4. Реалізувати функцію merge_sorted_lists для об'єднання двох відсортованих списків
5. Створити тести та демонстрацію в main.py

**Критерії прийняття:**
- ✅ Реалізовано функцію реверсування однозв'язного списку, яка змінює посилання між вузлами. Код виконується.
- ✅ Програмно реалізовано алгоритм сортування (функцію) для однозв'язного списку. Код виконується.
- ✅ Реалізовано функцію, що об'єднує два відсортовані однозв'язні списки в один відсортований список. Код виконується.

---

### Завдання 2: Рекурсія. Створення фрактала "дерево Піфагора"

**Файли для реалізації:**
- `task_2_pythagorean_tree/fractal.py` - рекурсивна логіка побудови
- `task_2_pythagorean_tree/visualization.py` - візуалізація з matplotlib
- `task_2_pythagorean_tree/main.py` - точка входу з параметром рівня рекурсії

**Кроки виконання:**
1. Реалізувати рекурсивну функцію calculate_pythagorean_tree для обчислення координат
2. Реалізувати візуалізацію з використанням matplotlib.patches.Rectangle
3. Додати можливість вказати рівень рекурсії через input() або аргументи командного рядка
4. Протестувати з різними рівнями рекурсії (2, 3, 4, 5)

**Критерії прийняття:**
- ✅ Код виконується. Програма візуалізує фрактал "дерево Піфагора".
- ✅ Користувач має можливість вказати рівень рекурсії.

---

### Завдання 3: Дерева, алгоритм Дейкстри

**Файли для реалізації:**
- `task_3_dijkstra/graph.py` - структура графа
- `task_3_dijkstra/binary_heap.py` - бінарна купа для оптимізації
- `task_3_dijkstra/dijkstra.py` - реалізація алгоритму Дейкстри
- `task_3_dijkstra/main.py` - демонстрація з прикладом графа

**Кроки виконання:**
1. Реалізувати клас Graph з методами add_vertex, add_edge, get_neighbors
2. Реалізувати клас MinHeap з методами insert, extract_min, decrease_key
3. Реалізувати алгоритм Дейкстри з використанням бінарної купи
4. Створити приклад графа та продемонструвати роботу алгоритму
5. Перевірити коректність обчислення найкоротших шляхів

**Критерії прийняття:**
- ✅ Програмно реалізовано алгоритм Дейкстри для знаходження найкоротшого шляху у графі з використанням бінарної купи (піраміди).
- ✅ У межах реалізації завдання створено граф, використано піраміду для оптимізації вибору вершин та виконано обчислення найкоротших шляхів від початкової вершини до всіх інших.

---

### Завдання 4: Візуалізація піраміди

**Файли для реалізації:**
- `task_4_heap_visualization/binary_heap.py` - структура бінарної купи
- `task_4_heap_visualization/visualization.py` - візуалізація з networkx та matplotlib
- `task_4_heap_visualization/main.py` - створення та відображення купи

**Кроки виконання:**
1. Реалізувати клас BinaryHeap з методом insert та build_tree_from_heap
2. Використати код з завдання для побудови дерева (функції add_edges та draw_tree)
3. Адаптувати код для відображення структури купи
4. Створити приклад купи та візуалізувати її

**Критерії прийняття:**
- ✅ Код виконується. Функція візуалізує бінарну купу.

---

### Завдання 5: Візуалізація обходу бінарного дерева

**Файли для реалізації:**
- `task_5_tree_traversal/binary_tree.py` - структура бінарного дерева
- `task_5_tree_traversal/traversal.py` - DFS та BFS (без рекурсії)
- `task_5_tree_traversal/visualization.py` - візуалізація з кольоровим кодуванням
- `task_5_tree_traversal/main.py` - демонстрація обходів

**Кроки виконання:**
1. Реалізувати функцію generate_color для генерації кольорів у форматі HEX
2. Реалізувати dfs_traversal з використанням стеку (не рекурсія)
3. Реалізувати bfs_traversal з використанням черги
4. Реалізувати apply_colors_to_traversal для застосування кольорів
5. Візуалізувати обидва обходи з кольоровим кодуванням

**Критерії прийняття:**
- ✅ Програмно реалізовано алгоритми DFS і BFS для візуалізації обходу дерева в глибину та в ширину. Використано стек та чергу.
- ✅ Кольори вузлів змінюються від темних до світлих відтінків залежно від порядку обходу.

---

### Завдання 6: Жадібні алгоритми та динамічне програмування

**Файли для реалізації:**
- `task_6_greedy_dp/greedy.py` - жадібний алгоритм вибору їжі
- `task_6_greedy_dp/dynamic_programming.py` - алгоритм динамічного програмування
- `task_6_greedy_dp/main.py` - порівняння результатів

**Кроки виконання:**
1. Реалізувати greedy_algorithm:
   - Обчислити співвідношення калорій/вартість для кожної страви
   - Відсортувати страви за цим співвідношенням
   - Вибирати страви по черзі, поки не перевищимо бюджет
2. Реалізувати dynamic_programming:
   - Створити таблицю DP для задачі про рюкзак
   - Заповнити таблицю та відстежити оптимальний набір страв
3. Порівняти результати обох алгоритмів для різних бюджетів

**Критерії прийняття:**
- ✅ Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає назви страв, максимізуючи співвідношення калорій до вартості, не перевищуючи заданий бюджет.
- ✅ Програмно реалізовано функцію, яка використовує принцип динамічного програмування. Код виконується і повертає оптимальний набір страв для максимізації калорійності при заданому бюджеті.

---

### Завдання 7: Використання методу Монте-Карло

**Файли для реалізації:**
- `task_7_monte_carlo/monte_carlo.py` - симуляція кидків кубиків
- `task_7_monte_carlo/visualization.py` - таблиці та графіки ймовірностей
- `task_7_monte_carlo/main.py` - порівняння з аналітичними розрахунками

**Кроки виконання:**
1. Реалізувати monte_carlo_simulation для симуляції кидків двох кубиків
2. Реалізувати analytical_probabilities для аналітичних розрахунків
3. Створити функцію create_probability_table для таблиці порівняння
4. Створити функцію plot_probabilities для графіку
5. Зробити висновки щодо правильності розрахунків та оформити їх у README.md

**Критерії прийняття:**
- ✅ Програмно реалізовано алгоритм для моделювання кидання двох ігрових кубиків і побудови таблиці сум та їх імовірностей за допомогою методу Монте-Карло.
- ✅ Код виконується та імітує велику кількість кидків кубиків, обчислює суми чисел, які випадають на кубиках, підраховує, скільки разів кожна можлива сума з'являється у процесі симуляції, і визначає ймовірність кожної можливої суми.
- ✅ Створено таблицю або графік, який відображає ймовірності кожної суми, виявлені за допомогою методу Монте-Карло.
- ✅ Зроблено висновки щодо правильності розрахунків шляхом порівняння отриманих за допомогою методу Монте-Карло результатів та результатів аналітичних розрахунків. Висновки оформлено у вигляді файлу readme.md фінального завдання.

---

## Чеклист перед здачею

### Загальні вимоги:
- [ ] Всі файли проекту завантажені в репозиторій goit-algo-fp
- [ ] Репозиторій публічний
- [ ] Кожне завдання має свій main.py, який можна запустити
- [ ] Код відповідає критеріям прийняття для всіх 7 завдань

### Перевірка кожного завдання:
- [ ] **Завдання 1**: Всі три функції (reverse, sort, merge) працюють коректно
- [ ] **Завдання 2**: Фрактал візуалізується, можна вказати рівень рекурсії
- [ ] **Завдання 3**: Алгоритм Дейкстри працює з бінарною купою
- [ ] **Завдання 4**: Бінарна купа візуалізується коректно
- [ ] **Завдання 5**: DFS та BFS працюють без рекурсії, кольори змінюються
- [ ] **Завдання 6**: Обидва алгоритми (жадібний та ДП) працюють та повертають результати
- [ ] **Завдання 7**: Симуляція працює, є таблиця/графік, є висновки у README.md

### Формат здачі:
- [ ] Створено архів у форматі ФП_ПІБ.zip
- [ ] Прикріплено посилання на репозиторій у LMS
- [ ] Прикріплено архів з файлами у LMS

---

## Поради щодо виконання

1. **Почніть з простого**: Спочатку реалізуйте базову функціональність, потім додавайте оптимізації
2. **Тестуйте поступово**: Після кожної реалізованої функції перевіряйте її роботу
3. **Використовуйте коментарі**: Додавайте коментарі для складних алгоритмів
4. **Перевіряйте крайні випадки**: Порожні списки, один елемент, великі набори даних
5. **Візуалізація**: Переконайтеся, що всі графіки та візуалізації відображаються коректно

---

## Тестування

Проект включає повну тестову інфраструктуру з використанням **pytest**. Тести допомагають перевірити коректність реалізації та забезпечують надійність коду.

### Структура тестів

Тести організовані за комбінованим підходом:

1. **Базові тести (юніт-тести)** - знаходяться поруч з кодом у кожній папці `task_X/`:
   - `test_*.py` - тести для конкретних модулів
   - Перевіряють окремі функції та класи

2. **Інтеграційні тести** - знаходяться в централізованій папці `tests/`:
   - `tests/task_X/test_integration.py` - тести взаємодії компонентів
   - Перевіряють повну функціональність завдання

### Запуск тестів

```bash
# Встановити тестові залежності
uv sync --extra dev

# Запустити всі тести
pytest

# Запустити тести для конкретного завдання
pytest task_1_linked_list/
pytest tests/task_1/

# Запустити тільки юніт-тести
pytest -m unit

# Запустити тільки інтеграційні тести
pytest -m integration

# Запустити з покриттям коду
pytest --cov=task_1_linked_list --cov-report=html
```

### Перевірка тестів перед здачею

- [ ] Всі тести проходять успішно (`pytest` без помилок)
- [ ] Юніт-тести перевіряють основну функціональність
- [ ] Інтеграційні тести перевіряють повну роботу завдання
- [ ] Тести покривають крайні випадки (порожні структури, один елемент)

---

## Довідка

### Запуск проекту

Для активації віртуального середовища:
```bash
uv venv
source .venv/bin/activate  # Linux/Mac
# або
.venv\Scripts\activate  # Windows
```

Для встановлення залежностей:
```bash
uv sync
```

Для запуску конкретного завдання:
```bash
cd task_X_name
python main.py
```

### Залежності проекту

**Основні залежності:**
- **matplotlib**: для візуалізації графіків та фракталів
- **networkx**: для роботи з графами та деревами
- **numpy**: для математичних обчислень
- **pandas**: для роботи з таблицями даних

**Тестові залежності (опціональні):**
- **pytest**: фреймворк для тестування
- **pytest-cov**: для аналізу покриття коду

Встановлення тестових залежностей:
```bash
uv sync --extra dev
```

---

